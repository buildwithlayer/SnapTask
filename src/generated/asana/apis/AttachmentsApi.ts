/* tslint:disable */
/* eslint-disable */
/**
 * Asana
 * This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/openapi/master/defs/asana_oas.yaml).
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  ApproveAccessRequest200Response,
  ErrorResponse,
  GetAttachment200Response,
  GetAttachmentsForObject200Response,
} from '../models/index.js';
import {
    ApproveAccessRequest200ResponseFromJSON,
    ApproveAccessRequest200ResponseToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    GetAttachment200ResponseFromJSON,
    GetAttachment200ResponseToJSON,
    GetAttachmentsForObject200ResponseFromJSON,
    GetAttachmentsForObject200ResponseToJSON,
} from '../models/index.js';

export interface CreateAttachmentForObjectRequest {
    parent: string;
    optPretty?: boolean;
    optFields?: Array<CreateAttachmentForObjectOptFieldsEnum>;
    resourceSubtype?: CreateAttachmentForObjectResourceSubtypeEnum;
    file?: Blob;
    url?: string;
    name?: string;
    connectToApp?: boolean;
}

export interface DeleteAttachmentRequest {
    attachmentGid: string;
    optPretty?: boolean;
}

export interface GetAttachmentRequest {
    attachmentGid: string;
    optPretty?: boolean;
    optFields?: Array<GetAttachmentOptFieldsEnum>;
}

export interface GetAttachmentsForObjectRequest {
    parent: string;
    optPretty?: boolean;
    limit?: number;
    offset?: string;
    optFields?: Array<GetAttachmentsForObjectOptFieldsEnum>;
}

/**
 * 
 */
export class AttachmentsApi extends runtime.BaseAPI {

    /**
     * <b>Required scope: </b><code>attachments:write</code>  Upload an attachment.  This method uploads an attachment on an object and returns the compact record for the created attachment object. This is possible by either:  - Providing the URL of the external resource being attached, or - Downloading the file content first and then uploading it as any other attachment. Note that it is not possible to attach files from third party services such as Dropbox, Box, Vimeo & Google Drive via the API  The 100MB size limit on attachments in Asana is enforced on this endpoint.  This endpoint expects a multipart/form-data encoded request containing the full contents of the file to be uploaded.  Requests made should follow the HTTP/1.1 specification that line terminators are of the form `CRLF` or `\\r\\n` outlined [here](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#Basic-Rules) in order for the server to reliably and properly handle the request.  For file names that contain non-ASCII characters, the file name should be URL-encoded. For example, a file named `résumé.pdf` should be encoded as `r%C3%A9sum%C3%A9.pdf` and the `filename` parameter in the `Content-Disposition` header should be set to the encoded file name.  Below is an example of a cURL request with the `Content-Disposition` header:  ``` export ASANA_PAT=\"<YOUR_ASANA_PERSONAL_ACCESS_TOKEN>\" export PARENT_ID=\"<PARENT_GID>\" export ENCODED_NAME=\"r%C3%A9sum%C3%A9.pdf\" curl --location \'https://app.asana.com/api/1.0/attachments\' \\   --header \'Content-Type: multipart/form-data\' \\   --header \'Accept: application/json\' \\   --header \"Authorization: Bearer $ASANA_PAT\" \\   --form \"parent=$PARENT_ID\" \\   --form \"file=@/Users/exampleUser/Downloads/résumé.pdf;headers=\\\"Content-Disposition: form-data; name=\"file\"; filename=\"$ENCODED_NAME.pdf\"; filename*=UTF-8\'\'$ENCODED_NAME.pdf\\\"\" ```
     * Upload an attachment
     */
    async createAttachmentForObjectRaw(requestParameters: CreateAttachmentForObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAttachment200Response>> {
        if (requestParameters['parent'] == null) {
            throw new runtime.RequiredError(
                'parent',
                'Required parameter "parent" was null or undefined when calling createAttachmentForObject().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["attachments:write"]);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['resourceSubtype'] != null) {
            formParams.append('resource_subtype', requestParameters['resourceSubtype'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['parent'] != null) {
            formParams.append('parent', requestParameters['parent'] as any);
        }

        if (requestParameters['url'] != null) {
            formParams.append('url', requestParameters['url'] as any);
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['connectToApp'] != null) {
            formParams.append('connect_to_app', requestParameters['connectToApp'] as any);
        }


        let urlPath = `/attachments`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAttachment200ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>attachments:write</code>  Upload an attachment.  This method uploads an attachment on an object and returns the compact record for the created attachment object. This is possible by either:  - Providing the URL of the external resource being attached, or - Downloading the file content first and then uploading it as any other attachment. Note that it is not possible to attach files from third party services such as Dropbox, Box, Vimeo & Google Drive via the API  The 100MB size limit on attachments in Asana is enforced on this endpoint.  This endpoint expects a multipart/form-data encoded request containing the full contents of the file to be uploaded.  Requests made should follow the HTTP/1.1 specification that line terminators are of the form `CRLF` or `\\r\\n` outlined [here](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#Basic-Rules) in order for the server to reliably and properly handle the request.  For file names that contain non-ASCII characters, the file name should be URL-encoded. For example, a file named `résumé.pdf` should be encoded as `r%C3%A9sum%C3%A9.pdf` and the `filename` parameter in the `Content-Disposition` header should be set to the encoded file name.  Below is an example of a cURL request with the `Content-Disposition` header:  ``` export ASANA_PAT=\"<YOUR_ASANA_PERSONAL_ACCESS_TOKEN>\" export PARENT_ID=\"<PARENT_GID>\" export ENCODED_NAME=\"r%C3%A9sum%C3%A9.pdf\" curl --location \'https://app.asana.com/api/1.0/attachments\' \\   --header \'Content-Type: multipart/form-data\' \\   --header \'Accept: application/json\' \\   --header \"Authorization: Bearer $ASANA_PAT\" \\   --form \"parent=$PARENT_ID\" \\   --form \"file=@/Users/exampleUser/Downloads/résumé.pdf;headers=\\\"Content-Disposition: form-data; name=\"file\"; filename=\"$ENCODED_NAME.pdf\"; filename*=UTF-8\'\'$ENCODED_NAME.pdf\\\"\" ```
     * Upload an attachment
     */
    async createAttachmentForObject(requestParameters: CreateAttachmentForObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAttachment200Response> {
        const response = await this.createAttachmentForObjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>attachments:delete</code>  Deletes a specific, existing attachment.  Returns an empty data record.
     * Delete an attachment
     */
    async deleteAttachmentRaw(requestParameters: DeleteAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApproveAccessRequest200Response>> {
        if (requestParameters['attachmentGid'] == null) {
            throw new runtime.RequiredError(
                'attachmentGid',
                'Required parameter "attachmentGid" was null or undefined when calling deleteAttachment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["attachments:delete"]);
        }


        let urlPath = `/attachments/{attachment_gid}`;
        urlPath = urlPath.replace(`{${"attachment_gid"}}`, encodeURIComponent(String(requestParameters['attachmentGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApproveAccessRequest200ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>attachments:delete</code>  Deletes a specific, existing attachment.  Returns an empty data record.
     * Delete an attachment
     */
    async deleteAttachment(requestParameters: DeleteAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApproveAccessRequest200Response> {
        const response = await this.deleteAttachmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>attachments:read</code>  Get the full record for a single attachment.
     * Get an attachment
     */
    async getAttachmentRaw(requestParameters: GetAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAttachment200Response>> {
        if (requestParameters['attachmentGid'] == null) {
            throw new runtime.RequiredError(
                'attachmentGid',
                'Required parameter "attachmentGid" was null or undefined when calling getAttachment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["attachments:read"]);
        }


        let urlPath = `/attachments/{attachment_gid}`;
        urlPath = urlPath.replace(`{${"attachment_gid"}}`, encodeURIComponent(String(requestParameters['attachmentGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAttachment200ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>attachments:read</code>  Get the full record for a single attachment.
     * Get an attachment
     */
    async getAttachment(requestParameters: GetAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAttachment200Response> {
        const response = await this.getAttachmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>attachments:read</code>  Returns the compact records for all attachments on the object. There are three possible `parent` values for this request: `project`, `project_brief`, and `task`. For a project, an attachment refers to a file uploaded to the \"Key resources\" section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task.  Note that within the Asana app, inline images in the task description do not appear in the index of image thumbnails nor as stories in the task. However, requests made to `GET /attachments` for a task will return all of the images in the task, including inline images.
     * Get attachments from an object
     */
    async getAttachmentsForObjectRaw(requestParameters: GetAttachmentsForObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAttachmentsForObject200Response>> {
        if (requestParameters['parent'] == null) {
            throw new runtime.RequiredError(
                'parent',
                'Required parameter "parent" was null or undefined when calling getAttachmentsForObject().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['parent'] != null) {
            queryParameters['parent'] = requestParameters['parent'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["attachments:read"]);
        }


        let urlPath = `/attachments`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAttachmentsForObject200ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>attachments:read</code>  Returns the compact records for all attachments on the object. There are three possible `parent` values for this request: `project`, `project_brief`, and `task`. For a project, an attachment refers to a file uploaded to the \"Key resources\" section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task.  Note that within the Asana app, inline images in the task description do not appear in the index of image thumbnails nor as stories in the task. However, requests made to `GET /attachments` for a task will return all of the images in the task, including inline images.
     * Get attachments from an object
     */
    async getAttachmentsForObject(requestParameters: GetAttachmentsForObjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAttachmentsForObject200Response> {
        const response = await this.getAttachmentsForObjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CreateAttachmentForObjectOptFieldsEnum = {
    ConnectedToApp: 'connected_to_app',
    CreatedAt: 'created_at',
    DownloadUrl: 'download_url',
    Host: 'host',
    Name: 'name',
    Parent: 'parent',
    ParentCreatedBy: 'parent.created_by',
    ParentName: 'parent.name',
    ParentResourceSubtype: 'parent.resource_subtype',
    PermanentUrl: 'permanent_url',
    ResourceSubtype: 'resource_subtype',
    Size: 'size',
    ViewUrl: 'view_url'
} as const;
export type CreateAttachmentForObjectOptFieldsEnum = typeof CreateAttachmentForObjectOptFieldsEnum[keyof typeof CreateAttachmentForObjectOptFieldsEnum];
/**
 * @export
 */
export const CreateAttachmentForObjectResourceSubtypeEnum = {
    Asana: 'asana',
    Dropbox: 'dropbox',
    Gdrive: 'gdrive',
    Onedrive: 'onedrive',
    Box: 'box',
    Vimeo: 'vimeo',
    External: 'external'
} as const;
export type CreateAttachmentForObjectResourceSubtypeEnum = typeof CreateAttachmentForObjectResourceSubtypeEnum[keyof typeof CreateAttachmentForObjectResourceSubtypeEnum];
/**
 * @export
 */
export const GetAttachmentOptFieldsEnum = {
    ConnectedToApp: 'connected_to_app',
    CreatedAt: 'created_at',
    DownloadUrl: 'download_url',
    Host: 'host',
    Name: 'name',
    Parent: 'parent',
    ParentCreatedBy: 'parent.created_by',
    ParentName: 'parent.name',
    ParentResourceSubtype: 'parent.resource_subtype',
    PermanentUrl: 'permanent_url',
    ResourceSubtype: 'resource_subtype',
    Size: 'size',
    ViewUrl: 'view_url'
} as const;
export type GetAttachmentOptFieldsEnum = typeof GetAttachmentOptFieldsEnum[keyof typeof GetAttachmentOptFieldsEnum];
/**
 * @export
 */
export const GetAttachmentsForObjectOptFieldsEnum = {
    ConnectedToApp: 'connected_to_app',
    CreatedAt: 'created_at',
    DownloadUrl: 'download_url',
    Host: 'host',
    Name: 'name',
    Offset: 'offset',
    Parent: 'parent',
    ParentCreatedBy: 'parent.created_by',
    ParentName: 'parent.name',
    ParentResourceSubtype: 'parent.resource_subtype',
    Path: 'path',
    PermanentUrl: 'permanent_url',
    ResourceSubtype: 'resource_subtype',
    Size: 'size',
    Uri: 'uri',
    ViewUrl: 'view_url'
} as const;
export type GetAttachmentsForObjectOptFieldsEnum = typeof GetAttachmentsForObjectOptFieldsEnum[keyof typeof GetAttachmentsForObjectOptFieldsEnum];
