/* tslint:disable */
/* eslint-disable */
/**
 * Asana
 * This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/openapi/master/defs/asana_oas.yaml).
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  ApproveAccessRequest200Response,
  CreateTag201Response,
  CreateTagForWorkspaceRequest,
  CreateTagRequest,
  ErrorResponse,
  GetTags200Response,
  UpdateTagRequest,
} from '../models/index.js';
import {
    ApproveAccessRequest200ResponseFromJSON,
    ApproveAccessRequest200ResponseToJSON,
    CreateTag201ResponseFromJSON,
    CreateTag201ResponseToJSON,
    CreateTagForWorkspaceRequestFromJSON,
    CreateTagForWorkspaceRequestToJSON,
    CreateTagRequestFromJSON,
    CreateTagRequestToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    GetTags200ResponseFromJSON,
    GetTags200ResponseToJSON,
    UpdateTagRequestFromJSON,
    UpdateTagRequestToJSON,
} from '../models/index.js';

export interface CreateTagOperationRequest {
    createTagRequest: CreateTagRequest;
    optPretty?: boolean;
    optFields?: Array<CreateTagOperationOptFieldsEnum>;
}

export interface CreateTagForWorkspaceOperationRequest {
    workspaceGid: string;
    createTagForWorkspaceRequest: CreateTagForWorkspaceRequest;
    optPretty?: boolean;
    optFields?: Array<CreateTagForWorkspaceOperationOptFieldsEnum>;
}

export interface DeleteTagRequest {
    tagGid: string;
    optPretty?: boolean;
}

export interface GetTagRequest {
    tagGid: string;
    optPretty?: boolean;
    optFields?: Array<GetTagOptFieldsEnum>;
}

export interface GetTagsRequest {
    optPretty?: boolean;
    limit?: number;
    offset?: string;
    workspace?: string;
    optFields?: Array<GetTagsOptFieldsEnum>;
}

export interface GetTagsForTaskRequest {
    taskGid: string;
    optPretty?: boolean;
    limit?: number;
    offset?: string;
    optFields?: Array<GetTagsForTaskOptFieldsEnum>;
}

export interface GetTagsForWorkspaceRequest {
    workspaceGid: string;
    optPretty?: boolean;
    limit?: number;
    offset?: string;
    optFields?: Array<GetTagsForWorkspaceOptFieldsEnum>;
}

export interface UpdateTagOperationRequest {
    tagGid: string;
    updateTagRequest: UpdateTagRequest;
    optPretty?: boolean;
    optFields?: Array<UpdateTagOperationOptFieldsEnum>;
}

/**
 * 
 */
export class TagsApi extends runtime.BaseAPI {

    /**
     * <b>Required scope: </b><code>tags:write</code>  Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * Create a tag
     */
    async createTagRaw(requestParameters: CreateTagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTag201Response>> {
        if (requestParameters['createTagRequest'] == null) {
            throw new runtime.RequiredError(
                'createTagRequest',
                'Required parameter "createTagRequest" was null or undefined when calling createTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["tags:write"]);
        }


        let urlPath = `/tags`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTagRequestToJSON(requestParameters['createTagRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTag201ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>tags:write</code>  Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * Create a tag
     */
    async createTag(requestParameters: CreateTagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTag201Response> {
        const response = await this.createTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>tags:write</code>  Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * Create a tag in a workspace
     */
    async createTagForWorkspaceRaw(requestParameters: CreateTagForWorkspaceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTag201Response>> {
        if (requestParameters['workspaceGid'] == null) {
            throw new runtime.RequiredError(
                'workspaceGid',
                'Required parameter "workspaceGid" was null or undefined when calling createTagForWorkspace().'
            );
        }

        if (requestParameters['createTagForWorkspaceRequest'] == null) {
            throw new runtime.RequiredError(
                'createTagForWorkspaceRequest',
                'Required parameter "createTagForWorkspaceRequest" was null or undefined when calling createTagForWorkspace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["tags:write"]);
        }


        let urlPath = `/workspaces/{workspace_gid}/tags`;
        urlPath = urlPath.replace(`{${"workspace_gid"}}`, encodeURIComponent(String(requestParameters['workspaceGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTagForWorkspaceRequestToJSON(requestParameters['createTagForWorkspaceRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTag201ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>tags:write</code>  Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * Create a tag in a workspace
     */
    async createTagForWorkspace(requestParameters: CreateTagForWorkspaceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTag201Response> {
        const response = await this.createTagForWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A specific, existing tag can be deleted by making a DELETE request on the URL for that tag.  Returns an empty data record.
     * Delete a tag
     */
    async deleteTagRaw(requestParameters: DeleteTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApproveAccessRequest200Response>> {
        if (requestParameters['tagGid'] == null) {
            throw new runtime.RequiredError(
                'tagGid',
                'Required parameter "tagGid" was null or undefined when calling deleteTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("personalAccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }


        let urlPath = `/tags/{tag_gid}`;
        urlPath = urlPath.replace(`{${"tag_gid"}}`, encodeURIComponent(String(requestParameters['tagGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApproveAccessRequest200ResponseFromJSON(jsonValue));
    }

    /**
     * A specific, existing tag can be deleted by making a DELETE request on the URL for that tag.  Returns an empty data record.
     * Delete a tag
     */
    async deleteTag(requestParameters: DeleteTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApproveAccessRequest200Response> {
        const response = await this.deleteTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>tags:read</code>  <table>   <tr>     <th>Field</th>     <th>Required Scope</th>   </tr>   <tr>     <td><code>workspace</code></td>     <td><code>workspaces:read</code></td>   </tr>   <tr>     <td><code>followers</code></td>     <td><code>users:read</code></td>   </tr> </table>  Returns the complete tag record for a single tag.
     * Get a tag
     */
    async getTagRaw(requestParameters: GetTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTag201Response>> {
        if (requestParameters['tagGid'] == null) {
            throw new runtime.RequiredError(
                'tagGid',
                'Required parameter "tagGid" was null or undefined when calling getTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["tags:read"]);
        }


        let urlPath = `/tags/{tag_gid}`;
        urlPath = urlPath.replace(`{${"tag_gid"}}`, encodeURIComponent(String(requestParameters['tagGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTag201ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>tags:read</code>  <table>   <tr>     <th>Field</th>     <th>Required Scope</th>   </tr>   <tr>     <td><code>workspace</code></td>     <td><code>workspaces:read</code></td>   </tr>   <tr>     <td><code>followers</code></td>     <td><code>users:read</code></td>   </tr> </table>  Returns the complete tag record for a single tag.
     * Get a tag
     */
    async getTag(requestParameters: GetTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTag201Response> {
        const response = await this.getTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>tags:read</code>  Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * Get multiple tags
     */
    async getTagsRaw(requestParameters: GetTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTags200Response>> {
        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['workspace'] != null) {
            queryParameters['workspace'] = requestParameters['workspace'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["tags:read"]);
        }


        let urlPath = `/tags`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTags200ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>tags:read</code>  Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * Get multiple tags
     */
    async getTags(requestParameters: GetTagsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTags200Response> {
        const response = await this.getTagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>tags:read</code>  Get a compact representation of all of the tags the task has.
     * Get a task\'s tags
     */
    async getTagsForTaskRaw(requestParameters: GetTagsForTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTags200Response>> {
        if (requestParameters['taskGid'] == null) {
            throw new runtime.RequiredError(
                'taskGid',
                'Required parameter "taskGid" was null or undefined when calling getTagsForTask().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["tags:read"]);
        }


        let urlPath = `/tasks/{task_gid}/tags`;
        urlPath = urlPath.replace(`{${"task_gid"}}`, encodeURIComponent(String(requestParameters['taskGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTags200ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>tags:read</code>  Get a compact representation of all of the tags the task has.
     * Get a task\'s tags
     */
    async getTagsForTask(requestParameters: GetTagsForTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTags200Response> {
        const response = await this.getTagsForTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>tags:read</code>  Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * Get tags in a workspace
     */
    async getTagsForWorkspaceRaw(requestParameters: GetTagsForWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTags200Response>> {
        if (requestParameters['workspaceGid'] == null) {
            throw new runtime.RequiredError(
                'workspaceGid',
                'Required parameter "workspaceGid" was null or undefined when calling getTagsForWorkspace().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["tags:read"]);
        }


        let urlPath = `/workspaces/{workspace_gid}/tags`;
        urlPath = urlPath.replace(`{${"workspace_gid"}}`, encodeURIComponent(String(requestParameters['workspaceGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTags200ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>tags:read</code>  Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * Get tags in a workspace
     */
    async getTagsForWorkspace(requestParameters: GetTagsForWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTags200Response> {
        const response = await this.getTagsForWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <b>Required scope: </b><code>tags:write</code>  Updates the properties of a tag. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.
     * Update a tag
     */
    async updateTagRaw(requestParameters: UpdateTagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTag201Response>> {
        if (requestParameters['tagGid'] == null) {
            throw new runtime.RequiredError(
                'tagGid',
                'Required parameter "tagGid" was null or undefined when calling updateTag().'
            );
        }

        if (requestParameters['updateTagRequest'] == null) {
            throw new runtime.RequiredError(
                'updateTagRequest',
                'Required parameter "updateTagRequest" was null or undefined when calling updateTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", ["tags:write"]);
        }


        let urlPath = `/tags/{tag_gid}`;
        urlPath = urlPath.replace(`{${"tag_gid"}}`, encodeURIComponent(String(requestParameters['tagGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTagRequestToJSON(requestParameters['updateTagRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTag201ResponseFromJSON(jsonValue));
    }

    /**
     * <b>Required scope: </b><code>tags:write</code>  Updates the properties of a tag. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.
     * Update a tag
     */
    async updateTag(requestParameters: UpdateTagOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTag201Response> {
        const response = await this.updateTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CreateTagOperationOptFieldsEnum = {
    Color: 'color',
    CreatedAt: 'created_at',
    Followers: 'followers',
    FollowersName: 'followers.name',
    Name: 'name',
    Notes: 'notes',
    PermalinkUrl: 'permalink_url',
    Workspace: 'workspace',
    WorkspaceName: 'workspace.name'
} as const;
export type CreateTagOperationOptFieldsEnum = typeof CreateTagOperationOptFieldsEnum[keyof typeof CreateTagOperationOptFieldsEnum];
/**
 * @export
 */
export const CreateTagForWorkspaceOperationOptFieldsEnum = {
    Color: 'color',
    CreatedAt: 'created_at',
    Followers: 'followers',
    FollowersName: 'followers.name',
    Name: 'name',
    Notes: 'notes',
    PermalinkUrl: 'permalink_url',
    Workspace: 'workspace',
    WorkspaceName: 'workspace.name'
} as const;
export type CreateTagForWorkspaceOperationOptFieldsEnum = typeof CreateTagForWorkspaceOperationOptFieldsEnum[keyof typeof CreateTagForWorkspaceOperationOptFieldsEnum];
/**
 * @export
 */
export const GetTagOptFieldsEnum = {
    Color: 'color',
    CreatedAt: 'created_at',
    Followers: 'followers',
    FollowersName: 'followers.name',
    Name: 'name',
    Notes: 'notes',
    PermalinkUrl: 'permalink_url',
    Workspace: 'workspace',
    WorkspaceName: 'workspace.name'
} as const;
export type GetTagOptFieldsEnum = typeof GetTagOptFieldsEnum[keyof typeof GetTagOptFieldsEnum];
/**
 * @export
 */
export const GetTagsOptFieldsEnum = {
    Color: 'color',
    CreatedAt: 'created_at',
    Followers: 'followers',
    FollowersName: 'followers.name',
    Name: 'name',
    Notes: 'notes',
    Offset: 'offset',
    Path: 'path',
    PermalinkUrl: 'permalink_url',
    Uri: 'uri',
    Workspace: 'workspace',
    WorkspaceName: 'workspace.name'
} as const;
export type GetTagsOptFieldsEnum = typeof GetTagsOptFieldsEnum[keyof typeof GetTagsOptFieldsEnum];
/**
 * @export
 */
export const GetTagsForTaskOptFieldsEnum = {
    Color: 'color',
    CreatedAt: 'created_at',
    Followers: 'followers',
    FollowersName: 'followers.name',
    Name: 'name',
    Notes: 'notes',
    Offset: 'offset',
    Path: 'path',
    PermalinkUrl: 'permalink_url',
    Uri: 'uri',
    Workspace: 'workspace',
    WorkspaceName: 'workspace.name'
} as const;
export type GetTagsForTaskOptFieldsEnum = typeof GetTagsForTaskOptFieldsEnum[keyof typeof GetTagsForTaskOptFieldsEnum];
/**
 * @export
 */
export const GetTagsForWorkspaceOptFieldsEnum = {
    Color: 'color',
    CreatedAt: 'created_at',
    Followers: 'followers',
    FollowersName: 'followers.name',
    Name: 'name',
    Notes: 'notes',
    Offset: 'offset',
    Path: 'path',
    PermalinkUrl: 'permalink_url',
    Uri: 'uri',
    Workspace: 'workspace',
    WorkspaceName: 'workspace.name'
} as const;
export type GetTagsForWorkspaceOptFieldsEnum = typeof GetTagsForWorkspaceOptFieldsEnum[keyof typeof GetTagsForWorkspaceOptFieldsEnum];
/**
 * @export
 */
export const UpdateTagOperationOptFieldsEnum = {
    Color: 'color',
    CreatedAt: 'created_at',
    Followers: 'followers',
    FollowersName: 'followers.name',
    Name: 'name',
    Notes: 'notes',
    PermalinkUrl: 'permalink_url',
    Workspace: 'workspace',
    WorkspaceName: 'workspace.name'
} as const;
export type UpdateTagOperationOptFieldsEnum = typeof UpdateTagOperationOptFieldsEnum[keyof typeof UpdateTagOperationOptFieldsEnum];
