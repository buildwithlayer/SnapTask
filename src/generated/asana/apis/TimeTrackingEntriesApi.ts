/* tslint:disable */
/* eslint-disable */
/**
 * Asana
 * This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/openapi/master/defs/asana_oas.yaml).
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  ApproveAccessRequest200Response,
  CreateTimeTrackingEntry201Response,
  CreateTimeTrackingEntryRequest,
  ErrorResponse,
  GetTimeTrackingEntriesForTask200Response,
  UpdateTimeTrackingEntryRequest,
} from '../models/index.js';
import {
    ApproveAccessRequest200ResponseFromJSON,
    ApproveAccessRequest200ResponseToJSON,
    CreateTimeTrackingEntry201ResponseFromJSON,
    CreateTimeTrackingEntry201ResponseToJSON,
    CreateTimeTrackingEntryRequestFromJSON,
    CreateTimeTrackingEntryRequestToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    GetTimeTrackingEntriesForTask200ResponseFromJSON,
    GetTimeTrackingEntriesForTask200ResponseToJSON,
    UpdateTimeTrackingEntryRequestFromJSON,
    UpdateTimeTrackingEntryRequestToJSON,
} from '../models/index.js';

export interface CreateTimeTrackingEntryOperationRequest {
    taskGid: string;
    createTimeTrackingEntryRequest: CreateTimeTrackingEntryRequest;
    optPretty?: boolean;
    optFields?: Array<CreateTimeTrackingEntryOperationOptFieldsEnum>;
}

export interface DeleteTimeTrackingEntryRequest {
    timeTrackingEntryGid: string;
    optPretty?: boolean;
}

export interface GetTimeTrackingEntriesRequest {
    optPretty?: boolean;
    task?: string;
    attributableTo?: string;
    portfolio?: string;
    user?: string;
    workspace?: string;
    limit?: number;
    offset?: string;
    optFields?: Array<GetTimeTrackingEntriesOptFieldsEnum>;
}

export interface GetTimeTrackingEntriesForTaskRequest {
    taskGid: string;
    optPretty?: boolean;
    limit?: number;
    offset?: string;
    optFields?: Array<GetTimeTrackingEntriesForTaskOptFieldsEnum>;
}

export interface GetTimeTrackingEntryRequest {
    timeTrackingEntryGid: string;
    optPretty?: boolean;
    optFields?: Array<GetTimeTrackingEntryOptFieldsEnum>;
}

export interface UpdateTimeTrackingEntryOperationRequest {
    timeTrackingEntryGid: string;
    updateTimeTrackingEntryRequest: UpdateTimeTrackingEntryRequest;
    optPretty?: boolean;
    optFields?: Array<UpdateTimeTrackingEntryOperationOptFieldsEnum>;
}

/**
 * 
 */
export class TimeTrackingEntriesApi extends runtime.BaseAPI {

    /**
     * Creates a time tracking entry on a given task.  Returns the record of the newly created time tracking entry.
     * Create a time tracking entry
     */
    async createTimeTrackingEntryRaw(requestParameters: CreateTimeTrackingEntryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTimeTrackingEntry201Response>> {
        if (requestParameters['taskGid'] == null) {
            throw new runtime.RequiredError(
                'taskGid',
                'Required parameter "taskGid" was null or undefined when calling createTimeTrackingEntry().'
            );
        }

        if (requestParameters['createTimeTrackingEntryRequest'] == null) {
            throw new runtime.RequiredError(
                'createTimeTrackingEntryRequest',
                'Required parameter "createTimeTrackingEntryRequest" was null or undefined when calling createTimeTrackingEntry().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("personalAccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }


        let urlPath = `/tasks/{task_gid}/time_tracking_entries`;
        urlPath = urlPath.replace(`{${"task_gid"}}`, encodeURIComponent(String(requestParameters['taskGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTimeTrackingEntryRequestToJSON(requestParameters['createTimeTrackingEntryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTimeTrackingEntry201ResponseFromJSON(jsonValue));
    }

    /**
     * Creates a time tracking entry on a given task.  Returns the record of the newly created time tracking entry.
     * Create a time tracking entry
     */
    async createTimeTrackingEntry(requestParameters: CreateTimeTrackingEntryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTimeTrackingEntry201Response> {
        const response = await this.createTimeTrackingEntryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A specific, existing time tracking entry can be deleted by making a `DELETE` request on the URL for that time tracking entry.  Returns an empty data record.
     * Delete a time tracking entry
     */
    async deleteTimeTrackingEntryRaw(requestParameters: DeleteTimeTrackingEntryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApproveAccessRequest200Response>> {
        if (requestParameters['timeTrackingEntryGid'] == null) {
            throw new runtime.RequiredError(
                'timeTrackingEntryGid',
                'Required parameter "timeTrackingEntryGid" was null or undefined when calling deleteTimeTrackingEntry().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("personalAccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }


        let urlPath = `/time_tracking_entries/{time_tracking_entry_gid}`;
        urlPath = urlPath.replace(`{${"time_tracking_entry_gid"}}`, encodeURIComponent(String(requestParameters['timeTrackingEntryGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApproveAccessRequest200ResponseFromJSON(jsonValue));
    }

    /**
     * A specific, existing time tracking entry can be deleted by making a `DELETE` request on the URL for that time tracking entry.  Returns an empty data record.
     * Delete a time tracking entry
     */
    async deleteTimeTrackingEntry(requestParameters: DeleteTimeTrackingEntryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApproveAccessRequest200Response> {
        const response = await this.deleteTimeTrackingEntryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of time tracking entries filtered to a task, attributed project, portfolio or user.
     * Get multiple time tracking entries
     */
    async getTimeTrackingEntriesRaw(requestParameters: GetTimeTrackingEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTimeTrackingEntriesForTask200Response>> {
        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['task'] != null) {
            queryParameters['task'] = requestParameters['task'];
        }

        if (requestParameters['attributableTo'] != null) {
            queryParameters['attributable_to'] = requestParameters['attributableTo'];
        }

        if (requestParameters['portfolio'] != null) {
            queryParameters['portfolio'] = requestParameters['portfolio'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        if (requestParameters['workspace'] != null) {
            queryParameters['workspace'] = requestParameters['workspace'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("personalAccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }


        let urlPath = `/time_tracking_entries`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTimeTrackingEntriesForTask200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of time tracking entries filtered to a task, attributed project, portfolio or user.
     * Get multiple time tracking entries
     */
    async getTimeTrackingEntries(requestParameters: GetTimeTrackingEntriesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTimeTrackingEntriesForTask200Response> {
        const response = await this.getTimeTrackingEntriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns time tracking entries for a given task.
     * Get time tracking entries for a task
     */
    async getTimeTrackingEntriesForTaskRaw(requestParameters: GetTimeTrackingEntriesForTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTimeTrackingEntriesForTask200Response>> {
        if (requestParameters['taskGid'] == null) {
            throw new runtime.RequiredError(
                'taskGid',
                'Required parameter "taskGid" was null or undefined when calling getTimeTrackingEntriesForTask().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("personalAccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }


        let urlPath = `/tasks/{task_gid}/time_tracking_entries`;
        urlPath = urlPath.replace(`{${"task_gid"}}`, encodeURIComponent(String(requestParameters['taskGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTimeTrackingEntriesForTask200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns time tracking entries for a given task.
     * Get time tracking entries for a task
     */
    async getTimeTrackingEntriesForTask(requestParameters: GetTimeTrackingEntriesForTaskRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTimeTrackingEntriesForTask200Response> {
        const response = await this.getTimeTrackingEntriesForTaskRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the complete time tracking entry record for a single time tracking entry.
     * Get a time tracking entry
     */
    async getTimeTrackingEntryRaw(requestParameters: GetTimeTrackingEntryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTimeTrackingEntry201Response>> {
        if (requestParameters['timeTrackingEntryGid'] == null) {
            throw new runtime.RequiredError(
                'timeTrackingEntryGid',
                'Required parameter "timeTrackingEntryGid" was null or undefined when calling getTimeTrackingEntry().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("personalAccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }


        let urlPath = `/time_tracking_entries/{time_tracking_entry_gid}`;
        urlPath = urlPath.replace(`{${"time_tracking_entry_gid"}}`, encodeURIComponent(String(requestParameters['timeTrackingEntryGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTimeTrackingEntry201ResponseFromJSON(jsonValue));
    }

    /**
     * Returns the complete time tracking entry record for a single time tracking entry.
     * Get a time tracking entry
     */
    async getTimeTrackingEntry(requestParameters: GetTimeTrackingEntryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTimeTrackingEntry201Response> {
        const response = await this.getTimeTrackingEntryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A specific, existing time tracking entry can be updated by making a `PUT` request on the URL for that time tracking entry. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated time tracking entry record.
     * Update a time tracking entry
     */
    async updateTimeTrackingEntryRaw(requestParameters: UpdateTimeTrackingEntryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTimeTrackingEntry201Response>> {
        if (requestParameters['timeTrackingEntryGid'] == null) {
            throw new runtime.RequiredError(
                'timeTrackingEntryGid',
                'Required parameter "timeTrackingEntryGid" was null or undefined when calling updateTimeTrackingEntry().'
            );
        }

        if (requestParameters['updateTimeTrackingEntryRequest'] == null) {
            throw new runtime.RequiredError(
                'updateTimeTrackingEntryRequest',
                'Required parameter "updateTimeTrackingEntryRequest" was null or undefined when calling updateTimeTrackingEntry().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['optPretty'] != null) {
            queryParameters['opt_pretty'] = requestParameters['optPretty'];
        }

        if (requestParameters['optFields'] != null) {
            queryParameters['opt_fields'] = requestParameters['optFields']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("personalAccessToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2", []);
        }


        let urlPath = `/time_tracking_entries/{time_tracking_entry_gid}`;
        urlPath = urlPath.replace(`{${"time_tracking_entry_gid"}}`, encodeURIComponent(String(requestParameters['timeTrackingEntryGid'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTimeTrackingEntryRequestToJSON(requestParameters['updateTimeTrackingEntryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTimeTrackingEntry201ResponseFromJSON(jsonValue));
    }

    /**
     * A specific, existing time tracking entry can be updated by making a `PUT` request on the URL for that time tracking entry. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated time tracking entry record.
     * Update a time tracking entry
     */
    async updateTimeTrackingEntry(requestParameters: UpdateTimeTrackingEntryOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTimeTrackingEntry201Response> {
        const response = await this.updateTimeTrackingEntryRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CreateTimeTrackingEntryOperationOptFieldsEnum = {
    ApprovalStatus: 'approval_status',
    AttributableTo: 'attributable_to',
    AttributableToName: 'attributable_to.name',
    BillableStatus: 'billable_status',
    CreatedAt: 'created_at',
    CreatedBy: 'created_by',
    CreatedByName: 'created_by.name',
    Description: 'description',
    DurationMinutes: 'duration_minutes',
    EnteredOn: 'entered_on',
    Task: 'task',
    TaskCreatedBy: 'task.created_by',
    TaskName: 'task.name',
    TaskResourceSubtype: 'task.resource_subtype'
} as const;
export type CreateTimeTrackingEntryOperationOptFieldsEnum = typeof CreateTimeTrackingEntryOperationOptFieldsEnum[keyof typeof CreateTimeTrackingEntryOperationOptFieldsEnum];
/**
 * @export
 */
export const GetTimeTrackingEntriesOptFieldsEnum = {
    AttributableTo: 'attributable_to',
    AttributableToName: 'attributable_to.name',
    CreatedBy: 'created_by',
    CreatedByName: 'created_by.name',
    DurationMinutes: 'duration_minutes',
    EnteredOn: 'entered_on',
    Offset: 'offset',
    Path: 'path',
    Uri: 'uri'
} as const;
export type GetTimeTrackingEntriesOptFieldsEnum = typeof GetTimeTrackingEntriesOptFieldsEnum[keyof typeof GetTimeTrackingEntriesOptFieldsEnum];
/**
 * @export
 */
export const GetTimeTrackingEntriesForTaskOptFieldsEnum = {
    AttributableTo: 'attributable_to',
    AttributableToName: 'attributable_to.name',
    CreatedBy: 'created_by',
    CreatedByName: 'created_by.name',
    DurationMinutes: 'duration_minutes',
    EnteredOn: 'entered_on',
    Offset: 'offset',
    Path: 'path',
    Uri: 'uri'
} as const;
export type GetTimeTrackingEntriesForTaskOptFieldsEnum = typeof GetTimeTrackingEntriesForTaskOptFieldsEnum[keyof typeof GetTimeTrackingEntriesForTaskOptFieldsEnum];
/**
 * @export
 */
export const GetTimeTrackingEntryOptFieldsEnum = {
    ApprovalStatus: 'approval_status',
    AttributableTo: 'attributable_to',
    AttributableToName: 'attributable_to.name',
    BillableStatus: 'billable_status',
    CreatedAt: 'created_at',
    CreatedBy: 'created_by',
    CreatedByName: 'created_by.name',
    Description: 'description',
    DurationMinutes: 'duration_minutes',
    EnteredOn: 'entered_on',
    Task: 'task',
    TaskCreatedBy: 'task.created_by',
    TaskName: 'task.name',
    TaskResourceSubtype: 'task.resource_subtype'
} as const;
export type GetTimeTrackingEntryOptFieldsEnum = typeof GetTimeTrackingEntryOptFieldsEnum[keyof typeof GetTimeTrackingEntryOptFieldsEnum];
/**
 * @export
 */
export const UpdateTimeTrackingEntryOperationOptFieldsEnum = {
    ApprovalStatus: 'approval_status',
    AttributableTo: 'attributable_to',
    AttributableToName: 'attributable_to.name',
    BillableStatus: 'billable_status',
    CreatedAt: 'created_at',
    CreatedBy: 'created_by',
    CreatedByName: 'created_by.name',
    Description: 'description',
    DurationMinutes: 'duration_minutes',
    EnteredOn: 'entered_on',
    Task: 'task',
    TaskCreatedBy: 'task.created_by',
    TaskName: 'task.name',
    TaskResourceSubtype: 'task.resource_subtype'
} as const;
export type UpdateTimeTrackingEntryOperationOptFieldsEnum = typeof UpdateTimeTrackingEntryOperationOptFieldsEnum[keyof typeof UpdateTimeTrackingEntryOperationOptFieldsEnum];
